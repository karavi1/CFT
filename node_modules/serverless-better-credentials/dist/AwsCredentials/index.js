"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const aws_sdk_1 = __importDefault(require("aws-sdk"));
const readline_1 = __importDefault(require("readline"));
const SsoCredentials_1 = __importDefault(require("../SsoCredentials"));
function isCredentialsOptions(c) {
    if (!c)
        return false;
    const hasValidId = typeof (c === null || c === void 0 ? void 0 : c.accessKeyId) === 'string' && c.accessKeyId !== 'undefined';
    const hasValidKey = typeof (c === null || c === void 0 ? void 0 : c.secretAccessKey) === 'string' && c.secretAccessKey !== 'undefined';
    const hasValidToken = typeof (c === null || c === void 0 ? void 0 : c.sessionToken) === 'string' && c.sessionToken !== 'undefined';
    return hasValidId && (hasValidKey || hasValidToken);
}
const profileProviderClasses = [
    aws_sdk_1.default.SharedIniFileCredentials,
    SsoCredentials_1.default,
    aws_sdk_1.default.ProcessCredentials,
    aws_sdk_1.default.ECSCredentials,
    aws_sdk_1.default.TokenFileWebIdentityCredentials,
    aws_sdk_1.default.EC2MetadataCredentials,
];
/*
 * The aws-sdk-js provides a built in mechanism for resolving credentials from multiple sources:
 *  https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/CredentialProviderChain.html
 * However, the credential resolution for the serverless framework differs significantly from the
 * AWS default provider chain (e.g. credentials and provides set by the yaml).
 *
 * This class allows us to define a more flexible order (see AwsProvider.getCredentials()),
 * while still using the aws-sdk-js supported framework; so we can more readily support future
 * ways of resolving credentials.
 *
 * Until https://github.com/aws/aws-sdk-js/issues/3122 is resolved, extending the
 * AWS.CredentialProviderChain does not result in AWS.Credentials that refresh using the chain.
 * Therefore we must extend AWS.Credentials directly and provide a refresh method that
 * resolves the chain ourselves.
 */
class AwsCredentials extends aws_sdk_1.default.Credentials {
    constructor(hintFn) {
        super('ACCESS_KEY_ID', 'SECRET_ACCESS_KEY');
        this.hint = 'No credentials resolved';
        this.hintShown = false;
        this.expired = true; // force refresh based on chain
        this.chain = new aws_sdk_1.default.CredentialProviderChain([]); // providers are added explicitly
        this.logHintFn = hintFn;
    }
    refresh(callback) {
        this.chain.resolve((err, res) => {
            if (err) {
                callback(err);
            }
            else if (!res) {
                const e = {
                    name: 'CredentialsError',
                    message: 'Unable to resolve credentials',
                    code: 'CredentialsError',
                    time: new Date(),
                };
                callback(e);
            }
            else {
                aws_sdk_1.default.Credentials.call(this, res);
                if (!this.hintShown) {
                    this.hintShown = true;
                    this.logHintFn(`credentials resolved ${this.hint}`);
                }
                callback();
            }
        });
    }
    addConfig(hint, credentials) {
        if (isCredentialsOptions(credentials)) {
            this.chain.providers.push(() => {
                this.hint = `from config: ${hint}`;
                return new aws_sdk_1.default.Credentials(credentials);
            });
        }
    }
    addEnvironment(hint, prefix) {
        if (prefix) {
            this.chain.providers.push(() => {
                this.hint = `from env: ${hint}`;
                return new aws_sdk_1.default.EnvironmentCredentials(prefix);
            });
        }
    }
    addProfile(hint, profile) {
        if (profile) {
            const params = { profile };
            if (process.env.AWS_SHARED_CREDENTIALS_FILE) {
                params.filename = process.env.AWS_SHARED_CREDENTIALS_FILE;
            }
            // Setup a MFA callback for asking the code from the user.
            params.tokenCodeFn = (mfaSerial, callback) => {
                const rl = readline_1.default.createInterface({ input: process.stdin, output: process.stdout });
                rl.question(`Enter MFA code for ${mfaSerial}: `, (answer) => {
                    rl.close();
                    callback(undefined, answer);
                });
            };
            profileProviderClasses.forEach((ProviderClass) => {
                this.chain.providers.push(() => {
                    this.hint = `from config ${ProviderClass.name}: ${hint} (${profile})`;
                    return new ProviderClass(params);
                });
            });
        }
    }
}
exports.default = AwsCredentials;
//# sourceMappingURL=index.js.map